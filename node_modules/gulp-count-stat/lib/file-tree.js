"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _path = require("path");

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FileTree = function () {
  function FileTree() {
    var treeOrPaths = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

    _classCallCheck(this, FileTree);

    if (treeOrPaths instanceof Array) {
      this.tree = new FileTreeNode();
      this.addPaths(treeOrPaths);
    } else {
      this.tree = new FileTreeNode(treeOrPaths);
    }
  }

  _createClass(FileTree, [{
    key: "add",
    value: function add(pathOrNode) {
      if (typeof pathOrNode === "string") {
        return _path2.default.normalize(pathOrNode).split(_path2.default.sep).reduce(function (parent, entry) {
          return parent.getChild(entry) || parent.addChild(entry);
        }, this.tree);
      } else {
        return this.tree.addChild(pathOrNode);
      }
    }
  }, {
    key: "addPaths",
    value: function addPaths(paths) {
      var _this = this;

      return paths.map(function (p) {
        return _this.add(p);
      });
    }
  }, {
    key: "get",
    value: function get(findPath) {
      var found = null;
      findPath = _path2.default.normalize(findPath);
      this.walk(function (node) {
        if (node.path === findPath) {
          found = node;
          return false;
        }
      });
      return found;
    }
  }, {
    key: "toString",
    value: function toString() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var lines = this.map(function (node) {
        return node.toTreeString(options);
      });
      if (options.skipRoot) lines.shift();
      return lines.join("\n");
    }
  }, {
    key: "toObject",
    value: function toObject() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return this.tree.toObject(options);
    }
  }, {
    key: "walk",
    value: function walk(fn) {
      var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var _ref$depthFirst = _ref.depthFirst;
      var depthFirst = _ref$depthFirst === undefined ? false : _ref$depthFirst;
      var _ref$leafOnly = _ref.leafOnly;
      var leafOnly = _ref$leafOnly === undefined ? false : _ref$leafOnly;

      var emitNode = leafOnly ? function (node) {
        return node.isLeaf ? fn(node) : true;
      } : fn;

      var walkNode = depthFirst ? function (node) {
        if (!node.children.every(walkNode)) return false;
        return emitNode(node) !== false;
      } : function (node) {
        if (emitNode(node) === false) return false;
        return node.children.every(walkNode);
      };

      walkNode(this.tree);
      return this;
    }
  }, {
    key: "walkDepthFirst",
    value: function walkDepthFirst(fn) {
      return this.walk(fn, { depthFirst: true });
    }
  }, {
    key: "walkLeaf",
    value: function walkLeaf(fn) {
      return this.walk(fn, { leafOnly: true });
    }
  }, {
    key: "map",
    value: function map(fn) {
      var results = [];
      this.walk(function (node) {
        results.push(fn(node));
      });
      return results;
    }
  }, {
    key: "mapLeaf",
    value: function mapLeaf(fn) {
      var results = [];
      this.walkLeaf(function (node) {
        results.push(fn(node));
      });
      return results;
    }
  }, {
    key: "print",
    value: function print(fn, options) {
      if ((typeof fn === "undefined" ? "undefined" : _typeof(fn)) === "object") {
        options = fn;fn = null;
      }
      options = options || {};

      return this.walk(function (node) {
        if (options.skipRoot && node.isRoot) return;
        var result = fn ? fn(node) : node.toTreeString(options);
        if ((typeof result === "undefined" ? "undefined" : _typeof(result)) === "object") {
          var prefix = result.prefix;
          var suffix = result.suffix;

          prefix = prefix ? prefix + " " : "";
          suffix = suffix ? " " + suffix : "";
          var treePrefix = node.getTreePrefix(options);
          console.log("" + treePrefix + prefix + node.toString() + suffix);
        } else if (typeof result !== "undefined" && result !== null) {
          console.log(result);
        }
      });
    }
  }, {
    key: "filter",
    value: function filter(fn) {
      return this._transform(function (node) {
        return fn(node) ? node : null;
      });
    }
  }, {
    key: "reject",
    value: function reject(fn) {
      return this._transform(function (node) {
        return fn(node) ? null : node;
      });
    }
  }, {
    key: "foldRoot",
    value: function foldRoot() {
      return this.fold(true);
    }
  }, {
    key: "fold",
    value: function fold() {
      var rootOnly = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

      return this._transform(function (node) {
        if ((node.isRoot || !rootOnly) && node.children.length === 1) {
          var child = node.children[0];
          child.name = _path2.default.join(node.name, child.name);
          return child;
        } else {
          return node;
        }
      });
    }
  }, {
    key: "sort",
    value: function sort(compareFunction) {
      this.tree.sort(compareFunction);
      return this;
    }
  }, {
    key: "_transform",
    value: function _transform(fn) {
      this.tree = function transformNode(node) {
        var newNode = fn(node);
        if (!newNode) {
          return null;
        }

        if (node !== newNode) {
          if (newNode.parent) {
            newNode.parent.removeChild(newNode);
          }
          if (node.parent) {
            node.parent.replaceChild(node, newNode);
          }
          return transformNode(newNode);
        }

        node.children.forEach(function (child, index) {
          var newChild = transformNode(child);
          if (!newChild) {
            node.removeChild(child);
          }
        });
        return node;
      }(this.tree);
      if (!this.tree) this.tree = new FileTreeNode();
      return this;
    }
  }]);

  return FileTree;
}();

var FileTreeNode = function () {
  function FileTreeNode(node) {
    _classCallCheck(this, FileTreeNode);

    node = node || {};
    this._name = node.name || ".";
    this.parent = node.parent || null;
    this.children = node.children || [];
    this.childNameToIndex = node.childNameToIndex || {};
    this.data = node.data || null;
  }

  _createClass(FileTreeNode, [{
    key: "getTreeIndent",
    value: function getTreeIndent(options) {
      if (!this.parent) return "";
      options = options || {};
      if (options.skipRoot && this.parent.isRoot) return "";
      return this.parent.getTreeIndent(options) + (this.isLastChild ? "     " : "│   ");
    }
  }, {
    key: "getTreePrefix",
    value: function getTreePrefix(options) {
      if (!this.parent) return "";
      options = options || {};
      if (options.skipRoot && this.parent.isRoot) return "";
      return this.parent.getTreeIndent(options) + (this.isLastChild ? "└─ " : "├─ ");
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.name;
    }
  }, {
    key: "toTreeString",
    value: function toTreeString(options) {
      return this.getTreePrefix(options) + this.name;
    }
  }, {
    key: "toObject",
    value: function toObject(options) {
      options = options || {};
      var obj = {};
      if (options.dataKey) {
        obj[options.dataKey] = this.data;
      }
      this.children.forEach(function (child) {
        return obj[child.name] = child.toObject(options);
      });
      return this.isRoot && this.name !== "." ? _defineProperty({}, this.name, obj) : obj;
    }
  }, {
    key: "getChild",
    value: function getChild(name) {
      var index = this.indexOfChild(name);
      return index >= 0 ? this.children[index] : null;
    }
  }, {
    key: "indexOfChild",
    value: function indexOfChild(name) {
      return this.childNameToIndex.hasOwnProperty(name) ? this.childNameToIndex[name] : -1;
    }
  }, {
    key: "addChild",
    value: function addChild(child) {
      return this.insertChild(child, this.children.length);
    }
  }, {
    key: "sort",
    value: function sort(compareFunction) {
      var _this2 = this;

      this.children.sort(compareFunction);
      this.childNameToIndex = {};
      this.children.forEach(function (child, index) {
        _this2.childNameToIndex[child.name] = index;
        child.sort(compareFunction);
      });
    }
  }, {
    key: "insertChild",
    value: function insertChild(child, index) {
      if (typeof child === "string") {
        child = new FileTreeNode({ name: child });
      } else if (!(child instanceof FileTreeNode)) {
        child = new FileTreeNode(child);
      }

      if (index < 0) {
        index = this.children.length + 1 + index;
      }
      index = Math.max(0, Math.min(this.children.length, index));

      if (child.parent && child.parent !== this) {
        child.parent.removeChild(child);
      }
      child.parent = this;

      var oldIndex = this.indexOfChild(child.name);
      if (oldIndex >= 0) {
        if (oldIndex === index) {
          this.children[index] = child;
        } else {
          this.childNameToIndex[child.name] = index;
          this.children.splice(oldIndex, 1);
          this.children.splice(oldIndex < index ? index - 1 : index, 0, child);
        }
      } else {
        this.childNameToIndex[child.name] = index;
        this.children.splice(index, 0, child);
      }
      return child;
    }
  }, {
    key: "removeChild",
    value: function removeChild(child) {
      var index = this.children.indexOf(child);
      if (index >= 0) {
        var node = this.children[index];
        node.parent = null;
        this.children.splice(index, 1);
        delete this.childNameToIndex[node.name];
        return node;
      } else {
        return null;
      }
    }
  }, {
    key: "replaceChild",
    value: function replaceChild(oldChild, newChild) {
      var index = this.children.indexOf(oldChild);
      if (oldChild) {
        this.removeChild(oldChild);
      }
      if (index >= 0) {
        return this.insertChild(newChild, index);
      } else {
        return this.addChild(newChild);
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      return new FileTreeNode(this);
    }
  }, {
    key: "name",
    get: function get() {
      return this._name;
    },
    set: function set(newName) {
      if (this.parent) {
        var existChild = this.parent.getChild(newName);
        if (existChild) {
          this.parent.replaceChild(existChild, this);
        } else {
          var index = this.parent.childNameToIndex[this.name];
          delete this.parent.childNameToIndex[this.name];
          this.parent.childNameToIndex[newName] = index;
        }
      }
      this._name = newName;
    }
  }, {
    key: "isRoot",
    get: function get() {
      return !this.parent;
    }
  }, {
    key: "isLeaf",
    get: function get() {
      return this.children.length === 0;
    }
  }, {
    key: "path",
    get: function get() {
      if (!this.parent) return this.name || ".";
      return _path2.default.join(this.parent.path, this.name);
    }
  }, {
    key: "childIndex",
    get: function get() {
      if (!this.parent) return 0;
      return this.parent.childNameToIndex[this.name] || 0;
    }
  }, {
    key: "isFirstChild",
    get: function get() {
      if (!this.parent) return false;
      return this.childIndex === 0;
    }
  }, {
    key: "isLastChild",
    get: function get() {
      if (!this.parent) return false;
      return this.childIndex === this.parent.children.length - 1;
    }
  }, {
    key: "depth",
    get: function get() {
      if (!this.parent) return 0;
      return this.parent.depth + 1;
    }
  }]);

  return FileTreeNode;
}();

function fileTree(paths) {
  return new FileTree(paths);
}
fileTree.FileTree = FileTree;

exports.default = fileTree;
module.exports = exports['default'];
//# sourceMappingURL=file-tree.js.map